---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-bootstrap
  namespace: vault
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-bootstrap
  namespace: vault
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "get", "list", "patch", "update"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["statefulsets"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-bootstrap
  namespace: vault
subjects:
- kind: ServiceAccount
  name: vault-bootstrap
  namespace: vault
roleRef:
  kind: Role
  name: vault-bootstrap
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-bootstrap
  namespace: vault
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app: vault-bootstrap
    spec:
      serviceAccountName: vault-bootstrap
      restartPolicy: Never
      containers:
      - name: vault-bootstrap
        image: hashicorp/vault:1.15.2
        command:
        - /bin/sh
        - -c
        - |
          set -e
          
          echo "üîê Starting Vault Bootstrap Automation..."
          
          # Install prerequisites
          apk add --no-cache curl jq aws-cli
          
          # Wait for Vault pod to be ready
          echo "‚è≥ Waiting for Vault pod to be ready..."
          until kubectl get pod vault-0 -n vault >/dev/null 2>&1; do
            echo "Waiting for Vault pod..."
            sleep 10
          done
          
          # Get Vault pod IP directly
          VAULT_POD_IP=$(kubectl get pod vault-0 -n vault -o jsonpath='{.status.podIP}')
          export VAULT_ADDR="http://$VAULT_POD_IP:8200"
          
          # Wait for Vault API to respond (even if not ready)
          until curl -s "$VAULT_ADDR/v1/sys/health" >/dev/null 2>&1; do
            echo "Waiting for Vault API on $VAULT_ADDR..."
            sleep 5
          done
          
          # Check if already initialized
          if vault status | grep -q "Initialized.*true"; then
            echo "‚úÖ Vault already initialized"
            
            # Check if keys exist
            if kubectl get secret vault-unseal-keys -n vault >/dev/null 2>&1; then
              echo "‚úÖ Unseal keys already exist, attempting unseal..."
              
              # Unseal if sealed
              if vault status | grep -q "Sealed.*true"; then
                KEY1=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key1}' | base64 -d)
                KEY2=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key2}' | base64 -d)
                KEY3=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key3}' | base64 -d)
                
                vault operator unseal "$KEY1"
                vault operator unseal "$KEY2"
                vault operator unseal "$KEY3"
                
                echo "‚úÖ Vault unsealed successfully"
              else
                echo "‚úÖ Vault already unsealed"
              fi
              
              exit 0
            fi
          fi
          
          # Initialize Vault
          echo "üîë Initializing Vault..."
          INIT_OUTPUT=$(vault operator init -key-shares=5 -key-threshold=3 -format=json)
          
          # Extract keys and token
          UNSEAL_KEY_1=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[0]')
          UNSEAL_KEY_2=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[1]')
          UNSEAL_KEY_3=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[2]')
          ROOT_TOKEN=$(echo "$INIT_OUTPUT" | jq -r '.root_token')
          
          # Store keys in Kubernetes secret
          kubectl create secret generic vault-unseal-keys -n vault \
            --from-literal=key1="$UNSEAL_KEY_1" \
            --from-literal=key2="$UNSEAL_KEY_2" \
            --from-literal=key3="$UNSEAL_KEY_3" \
            --from-literal=root-token="$ROOT_TOKEN"
          
          # Unseal Vault
          echo "üîì Unsealing Vault..."
          vault operator unseal "$UNSEAL_KEY_1"
          vault operator unseal "$UNSEAL_KEY_2"
          vault operator unseal "$UNSEAL_KEY_3"
          
          # Login with root token
          vault login "$ROOT_TOKEN"
          
          # Basic configuration
          echo "‚öôÔ∏è Configuring Vault..."
          
          # Enable secrets engines
          vault secrets enable -path=secret kv-v2 || true
          vault secrets enable -path=aws aws || true
          vault secrets enable -path=database database || true
          vault secrets enable -path=transit transit || true
          
          # Enable auth methods
          vault auth enable kubernetes || true
          vault auth enable aws || true
          
          # Create basic policies
          vault policy write admin - << 'POLICY'
          path "*" {
            capabilities = ["create", "read", "update", "delete", "list", "sudo"]
          }
          POLICY
          
          vault policy write platform-services - << 'POLICY'
          path "secret/data/platform/*" {
            capabilities = ["read", "list"]
          }
          path "aws/creds/platform-*" {
            capabilities = ["read"]
          }
          path "transit/encrypt/platform" {
            capabilities = ["create", "update"]
          }
          path "transit/decrypt/platform" {
            capabilities = ["create", "update"]
          }
          POLICY
          
          # Configure Kubernetes auth
          SA_JWT_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
          SA_CA_CRT=$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)
          K8S_HOST="https://kubernetes.default.svc:443"
          
          vault write auth/kubernetes/config \
            token_reviewer_jwt="$SA_JWT_TOKEN" \
            kubernetes_host="$K8S_HOST" \
            kubernetes_ca_cert="$SA_CA_CRT"
          
          # Create Kubernetes roles
          vault write auth/kubernetes/role/argocd \
            bound_service_account_names=argocd-server,argocd-application-controller \
            bound_service_account_namespaces=argocd \
            policies=platform-services \
            ttl=24h
          
          vault write auth/kubernetes/role/platform-services \
            bound_service_account_names="*" \
            bound_service_account_namespaces=vault,monitoring,airflow \
            policies=platform-services \
            ttl=8h
          
          # Store basic platform secrets
          vault kv put secret/platform/bootstrap \
            status="completed" \
            timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            cluster="base-app-layer-dev-platform"
          
          echo "‚úÖ Vault bootstrap completed successfully!"
          echo "üîë Root token and unseal keys stored in vault-unseal-keys secret"
          echo "üèóÔ∏è Basic auth methods and policies configured"
          
        env:
        - name: VAULT_SKIP_VERIFY
          value: "true"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vault-unsealer
  namespace: vault
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vault-unsealer
  template:
    metadata:
      labels:
        app: vault-unsealer
    spec:
      serviceAccountName: vault-bootstrap
      containers:
      - name: vault-unsealer
        image: hashicorp/vault:1.15.2
        command:
        - /bin/sh
        - -c
        - |
          set -e
          export VAULT_ADDR="http://vault.vault.svc.cluster.local:8200"
          
          while true; do
            if vault status >/dev/null 2>&1; then
              if vault status | grep -q "Sealed.*true"; then
                echo "üîì Vault is sealed, attempting unseal..."
                
                if kubectl get secret vault-unseal-keys -n vault >/dev/null 2>&1; then
                  KEY1=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key1}' | base64 -d)
                  KEY2=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key2}' | base64 -d)
                  KEY3=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key3}' | base64 -d)
                  
                  vault operator unseal "$KEY1" >/dev/null 2>&1 || true
                  vault operator unseal "$KEY2" >/dev/null 2>&1 || true
                  vault operator unseal "$KEY3" >/dev/null 2>&1 || true
                  
                  if vault status | grep -q "Sealed.*false"; then
                    echo "‚úÖ Vault successfully unsealed"
                  fi
                else
                  echo "‚ö†Ô∏è Unseal keys not found, waiting for bootstrap job..."
                fi
              else
                echo "‚úÖ Vault is unsealed"
              fi
            else
              echo "‚è≥ Vault not ready, waiting..."
            fi
            
            sleep 60
          done
        env:
        - name: VAULT_SKIP_VERIFY
          value: "true"
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"