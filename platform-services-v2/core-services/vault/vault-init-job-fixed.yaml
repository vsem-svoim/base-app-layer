---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init-fixed
  namespace: vault
  labels:
    app: vault-init
    component: initialization
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  template:
    metadata:
      labels:
        app: vault-init
    spec:
      restartPolicy: OnFailure
      serviceAccountName: vault-init
      containers:
      - name: vault-init
        image: alpine/k8s:1.28.4
        command:
        - sh
        - -c
        - |
          # Install vault CLI 1.15.2 (matching the deployed version) and jq
          apk add --no-cache curl unzip jq
          curl -fsSL https://releases.hashicorp.com/vault/1.15.2/vault_1.15.2_linux_amd64.zip -o vault.zip
          unzip vault.zip
          mv vault /usr/local/bin/
          rm vault.zip
          
          export VAULT_ADDR="http://vault.vault.svc.cluster.local:8200"
          export VAULT_FORMAT="json"
          
          echo "üîê Starting Vault initialization..."
          
          # Wait for Vault to be ready
          echo "‚è≥ Waiting for Vault to be ready..."
          until vault status 2>/dev/null | grep -E "(Initialized|Error)"; do
            echo "Vault not ready, waiting..."
            sleep 5
          done
          
          # Check if Vault is already initialized
          if vault status 2>/dev/null | grep -q "Initialized.*true"; then
            echo "‚úÖ Vault is already initialized"
            
            # Check if we need to unseal it
            if vault status 2>/dev/null | grep -q "Sealed.*true"; then
              echo "üîì Vault is sealed, checking for existing keys..."
              if kubectl get secret vault-unseal-keys -n vault >/dev/null 2>&1; then
                echo "üîë Found existing unseal keys, unsealing..."
                KEY1=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key1}' | base64 -d)
                KEY2=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key2}' | base64 -d)
                KEY3=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.key3}' | base64 -d)
                
                vault operator unseal "$KEY1"
                vault operator unseal "$KEY2"
                vault operator unseal "$KEY3"
                echo "‚úÖ Vault unsealed"
              else
                echo "‚ùå No unseal keys found and vault is sealed"
                exit 1
              fi
            else
              echo "‚úÖ Vault is already unsealed"
            fi
            
            # Authenticate with existing root token
            ROOT_TOKEN=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.root-token}' | base64 -d)
            vault auth "$ROOT_TOKEN"
            
          else
            echo "üîë Initializing Vault with 5 key shares, threshold 3..."
            INIT_OUTPUT=$(vault operator init -key-shares=5 -key-threshold=3 -format=json)
            
            # Extract keys and root token
            UNSEAL_KEY_1=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[0]')
            UNSEAL_KEY_2=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[1]')
            UNSEAL_KEY_3=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[2]')
            UNSEAL_KEY_4=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[3]')
            UNSEAL_KEY_5=$(echo "$INIT_OUTPUT" | jq -r '.unseal_keys_b64[4]')
            ROOT_TOKEN=$(echo "$INIT_OUTPUT" | jq -r '.root_token')
            
            # Create Kubernetes secret with unseal keys and root token
            kubectl create secret generic vault-unseal-keys -n vault \
              --from-literal=key1="$UNSEAL_KEY_1" \
              --from-literal=key2="$UNSEAL_KEY_2" \
              --from-literal=key3="$UNSEAL_KEY_3" \
              --from-literal=key4="$UNSEAL_KEY_4" \
              --from-literal=key5="$UNSEAL_KEY_5" \
              --from-literal=root-token="$ROOT_TOKEN" \
              --dry-run=client -o yaml | kubectl apply -f -
            
            echo "‚úÖ Vault initialized and keys stored in Kubernetes secret"
            
            # Unseal Vault
            echo "üîì Unsealing Vault..."
            vault operator unseal "$UNSEAL_KEY_1"
            vault operator unseal "$UNSEAL_KEY_2"
            vault operator unseal "$UNSEAL_KEY_3"
            
            # Login
            vault auth "$ROOT_TOKEN"
          fi
          
          echo "üîß Configuring Vault..."
          
          # Enable secrets engines (if not already enabled)
          vault secrets enable -path=secret kv-v2 2>/dev/null || echo "secret engine already enabled"
          vault secrets enable -path=platform kv-v2 2>/dev/null || echo "platform engine already enabled"
          
          # Create platform admin policy
          echo 'path "*" { capabilities = ["create", "read", "update", "delete", "list", "sudo"] }' | vault policy write platform-admin -
          
          # Create platform services policy  
          echo 'path "secret/data/platform/*" { capabilities = ["read", "list"] } path "platform/data/*" { capabilities = ["read", "list"] }' | vault policy write platform-services -
          
          # Enable Kubernetes auth (if not already enabled)
          vault auth enable kubernetes 2>/dev/null || echo "kubernetes auth already enabled"
          
          # Configure Kubernetes auth
          vault write auth/kubernetes/config \
            token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
            kubernetes_host="https://kubernetes.default.svc:443" \
            kubernetes_ca_cert="$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)"
          
          # Create roles for platform services
          vault write auth/kubernetes/role/argocd \
            bound_service_account_names=argocd-server,argocd-application-controller \
            bound_service_account_namespaces=argocd \
            policies=platform-services \
            ttl=24h
          
          # Store ArgoCD credentials in Vault
          ARGOCD_PASSWORD=$(kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath="{.data.password}" | base64 -d)
          vault kv put platform/argocd \
            username="admin" \
            password="$ARGOCD_PASSWORD" \
            url="http://argocd-server.argocd.svc.cluster.local"
          
          echo "‚úÖ Vault configuration completed successfully!"
          echo "üîê ArgoCD credentials stored in vault at platform/argocd"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
        env:
        - name: VAULT_SKIP_VERIFY
          value: "true"